"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (Buffer, randomBytes) {

  class ShamirThresholdSecretShare_GF256 {
    constructor() {
      this._randomBytes = randomBytes;
    }

    generate(secret, thresholdShares, totalShares) {
      if (!Buffer.isBuffer(secret)) {
        throw new Error("Expected secret to be a buffer");
      }

      if (thresholdShares <= 0) {
        throw new Error("Expected a positive threshold count");
      }

      if (null == totalShares) {
        totalShares = thresholdShares;
      } else if (totalShares < thresholdShares) {
        throw new Error("Expected the total count to be greater than the threshold count");
      }

      // initialize random Galois Field polynomials using provided
      // octects of secret for a0 coefficients
      const gf_polys = Array.from(secret, a0_secret => {
        let poly = this._randomBytes(thresholdShares);
        poly[0] = a0_secret; // use specified a0 as secret
        return poly;
      });

      // compute the shares given the Galois Field polynomials
      return new Array(totalShares).fill(null).map((_, i) => {
        const x = 1 + i,
              y_vec = gf_polys.map(poly => compute_poly(x, poly));
        return this._packShare(thresholdShares, x, y_vec);
      });
    }

    unlock(shares, valueIfUnderThreshold) {
      shares = Array.from(shares, this._unpackShare);
      const threshold = shares[0] && shares[0].threshold;
      if (!threshold || shares.length < threshold) {
        if (undefined !== valueIfUnderThreshold) {
          return valueIfUnderThreshold;
        }
        throw new Error('Number of shares did not meet threshold to unlock shared secret');
      }

      const u = shares.slice(0, threshold).map(s => s.x);

      // v_vec = zip @ shares.map(s => s.y_vec)
      const v_vec = Array.from(shares[0].y_vec, (_, i) => shares.map(s => s.y_vec[i]));

      // Lagrange interpolation integrates the split share into the original secret
      const secret_octects = lagrange_interpolate(u, v_vec);
      return Buffer(Array.from(secret_octects));
    }

    _packShare(threshold, x, y_vec) {
      return Buffer([threshold, x].concat(y_vec));
    }

    _unpackShare(buf) {
      if ('string' === typeof buf) {
        buf = Buffer.from(buf, 'base64');
      } else if (!Buffer.isBuffer(buf)) {
        throw new Error("Share must be a buffer or a string");
      }

      return { threshold: buf[0], x: buf[1], y_vec: buf.slice(2) };
    }

    static generateShares(secret, thresholdShares, totalShares) {
      return new ShamirThresholdSecretShare_GF256().generate(secret, thresholdShares, totalShares);
    }

    static unlockShares(shares_of_secret, valueIfUnderThreshold) {
      return new ShamirThresholdSecretShare_GF256().unlock(shares_of_secret, valueIfUnderThreshold);
    }
  }

  return ShamirThresholdSecretShare_GF256;
};

// vim: ts=2 sw=2 expandtab filetype=javascript
const { compute_poly, lagrange_interpolate } = require('./gf256_math');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvdHNzLmpzeSJdLCJuYW1lcyI6WyJCdWZmZXIiLCJyYW5kb21CeXRlcyIsIlNoYW1pclRocmVzaG9sZFNlY3JldFNoYXJlX0dGMjU2IiwiX3JhbmRvbUJ5dGVzIiwiZ2VuZXJhdGUiLCJzZWNyZXQiLCJ0aHJlc2hvbGRTaGFyZXMiLCJ0b3RhbFNoYXJlcyIsImlzQnVmZmVyIiwiRXJyb3IiLCJnZl9wb2x5cyIsIkFycmF5IiwiZnJvbSIsImEwX3NlY3JldCIsInBvbHkiLCJmaWxsIiwibWFwIiwiXyIsImkiLCJ4IiwieV92ZWMiLCJjb21wdXRlX3BvbHkiLCJfcGFja1NoYXJlIiwidW5sb2NrIiwic2hhcmVzIiwidmFsdWVJZlVuZGVyVGhyZXNob2xkIiwiX3VucGFja1NoYXJlIiwidGhyZXNob2xkIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwidSIsInNsaWNlIiwicyIsInZfdmVjIiwic2VjcmV0X29jdGVjdHMiLCJsYWdyYW5nZV9pbnRlcnBvbGF0ZSIsImNvbmNhdCIsImJ1ZiIsImdlbmVyYXRlU2hhcmVzIiwidW5sb2NrU2hhcmVzIiwic2hhcmVzX29mX3NlY3JldCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztrQkFHZSxVQUFTQSxNQUFULEVBQWlCQyxXQUFqQixFQUE4Qjs7QUFFM0MsUUFBTUMsZ0NBQU4sQ0FBdUM7QUFBQTtBQUFBLFdBNENyQ0MsWUE1Q3FDLEdBNEN0QkYsV0E1Q3NCO0FBQUE7O0FBQ3JDRyxhQUFTQyxNQUFULEVBQWlCQyxlQUFqQixFQUFrQ0MsV0FBbEMsRUFBK0M7QUFDN0MsVUFBRyxDQUFDUCxPQUFPUSxRQUFQLENBQWdCSCxNQUFoQixDQUFKLEVBQThCO0FBQzVCLGNBQU0sSUFBSUksS0FBSixDQUFZLGdDQUFaLENBQU47QUFBa0Q7O0FBRXBELFVBQUdILG1CQUFtQixDQUF0QixFQUEwQjtBQUN4QixjQUFNLElBQUlHLEtBQUosQ0FBWSxxQ0FBWixDQUFOO0FBQXVEOztBQUV6RCxVQUFHLFFBQVFGLFdB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QUE5QixFQUErQ0MsV0FBL0MsRUFBNEQ7QUFDMUQsYUFBTyxJQUFJTCxnQ0FBSixHQUNKRSxRQURJLENBQ0tDLE1BREwsRUFDYUMsZUFEYixFQUM4QkMsV0FEOUIsQ0FBUDtBQUNpRDs7QUFFbkQsV0FBT2dDLFlBQVAsQ0FBb0JDLGdCQUFwQixFQUFzQ2YscUJBQXRDLEVBQTZEO0FBQzNELGFBQU8sSUFBSXZCLGdDQUFKLEdBQ0pxQixNQURJLENBQ0dpQixnQkFESCxFQUNxQmYscUJBRHJCLENBQVA7QUFDa0Q7QUEvRGY7O0FBa0V2QyxTQUFPdkIsZ0NBQVA7QUFBdUMsQzs7QUF2RXpDO0FBQ0EsTUFBTSxFQUFDbUIsWUFBRCxFQUFlYyxvQkFBZixLQUF1Q00sUUFBUSxjQUFSLENBQTdDIiwiZmlsZSI6InRzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHZpbTogdHM9MiBzdz0yIGV4cGFuZHRhYiBmaWxldHlwZT1qYXZhc2NyaXB0XG5jb25zdCB7Y29tcHV0ZV9wb2x5LCBsYWdyYW5nZV9pbnRlcnBvbGF0ZX0gPSByZXF1aXJlKCcuL2dmMjU2X21hdGgnKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihCdWZmZXIsIHJhbmRvbUJ5dGVzKSA6OlxuXG4gIGNsYXNzIFNoYW1pclRocmVzaG9sZFNlY3JldFNoYXJlX0dGMjU2IDo6XG4gICAgZ2VuZXJhdGUoc2VjcmV0LCB0aHJlc2hvbGRTaGFyZXMsIHRvdGFsU2hhcmVzKSA6OlxuICAgICAgaWYgIUJ1ZmZlci5pc0J1ZmZlcihzZWNyZXQpIDo6XG4gICAgICAgIHRocm93IG5ldyBFcnJvciBAIFwiRXhwZWN0ZWQgc2VjcmV0IHRvIGJlIGEgYnVmZmVyXCJcblxuICAgICAgaWYgdGhyZXNob2xkU2hhcmVzIDw9IDAgOjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yIEAgXCJFeHBlY3RlZCBhIHBvc2l0aXZlIHRocmVzaG9sZCBjb3VudFwiXG5cbiAgICAgIGlmIG51bGwgPT0gdG90YWxTaGFyZXMgOjpcbiAgICAgICAgdG90YWxTaGFyZXMgPSB0aHJlc2hvbGRTaGFyZXNcbiAgICAgIGVsc2UgaWYgdG90YWxTaGFyZXMgPCB0aHJlc2hvbGRTaGFyZXMgOjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yIEAgXCJFeHBlY3RlZCB0aGUgdG90YWwgY291bnQgdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQgY291bnRcIlxuXG4gICAgICAvLyBpbml0aWFsaXplIHJhbmRvbSBHYWxvaXMgRmllbGQgcG9seW5vbWlhbHMgdXNpbmcgcHJvdmlkZWRcbiAgICAgIC8vIG9jdGVjdHMgb2Ygc2VjcmV0IGZvciBhMCBjb2VmZmljaWVudHNcbiAgICAgIGNvbnN0IGdmX3BvbHlzID0gQXJyYXkuZnJvbSBAIHNlY3JldCwgYTBfc2VjcmV0ID0+IDo6XG4gICAgICAgIGxldCBwb2x5ID0gdGhpcy5fcmFuZG9tQnl0ZXModGhyZXNob2xkU2hhcmVzKVxuICAgICAgICBwb2x5WzBdID0gYTBfc2VjcmV0IC8vIHVzZSBzcGVjaWZpZWQgYTAgYXMgc2VjcmV0XG4gICAgICAgIHJldHVybiBwb2x5XG5cbiAgICAgIC8vIGNvbXB1dGUgdGhlIHNoYXJlcyBnaXZlbiB0aGUgR2Fsb2lzIEZpZWxkIHBvbHlub21pYWxzXG4gICAgICByZXR1cm4gbmV3IEFycmF5KHRvdGFsU2hhcmVzKS5maWxsKG51bGwpLm1hcCBAIChfLCBpKSA9PiA6OlxuICAgICAgICBjb25zdCB4PTEraSwgeV92ZWM9Z2ZfcG9seXMubWFwIEAgcG9seSA9PiBjb21wdXRlX3BvbHkoeCwgcG9seSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2tTaGFyZSh0aHJlc2hvbGRTaGFyZXMsIHgsIHlfdmVjKVxuXG5cbiAgICB1bmxvY2soc2hhcmVzLCB2YWx1ZUlmVW5kZXJUaHJlc2hvbGQpIDo6XG4gICAgICBzaGFyZXMgPSBBcnJheS5mcm9tIEAgc2hhcmVzLCB0aGlzLl91bnBhY2tTaGFyZVxuICAgICAgY29uc3QgdGhyZXNob2xkID0gc2hhcmVzWzBdICYmIHNoYXJlc1swXS50aHJlc2hvbGRcbiAgICAgIGlmICF0aHJlc2hvbGQgfHwgc2hhcmVzLmxlbmd0aCA8IHRocmVzaG9sZCA6OlxuICAgICAgICBpZiB1bmRlZmluZWQgIT09IHZhbHVlSWZVbmRlclRocmVzaG9sZCA6OlxuICAgICAgICAgIHJldHVybiB2YWx1ZUlmVW5kZXJUaHJlc2hvbGRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2Ygc2hhcmVzIGRpZCBub3QgbWVldCB0aHJlc2hvbGQgdG8gdW5sb2NrIHNoYXJlZCBzZWNyZXQnKVxuXG4gICAgICBjb25zdCB1ID0gc2hhcmVzLnNsaWNlKDAsIHRocmVzaG9sZCkubWFwIEAgcyA9PiBzLnhcblxuICAgICAgLy8gdl92ZWMgPSB6aXAgQCBzaGFyZXMubWFwKHMgPT4gcy55X3ZlYylcbiAgICAgIGNvbnN0IHZfdmVjID0gQXJyYXkuZnJvbSBAIHNoYXJlc1swXS55X3ZlYywgKF8sIGkpID0+XG4gICAgICAgIHNoYXJlcy5tYXAgQCBzID0+IHMueV92ZWNbaV1cblxuICAgICAgLy8gTGFncmFuZ2UgaW50ZXJwb2xhdGlvbiBpbnRlZ3JhdGVzIHRoZSBzcGxpdCBzaGFyZSBpbnRvIHRoZSBvcmlnaW5hbCBzZWNyZXRcbiAgICAgIGNvbnN0IHNlY3JldF9vY3RlY3RzID0gbGFncmFuZ2VfaW50ZXJwb2xhdGUodSwgdl92ZWMpXG4gICAgICByZXR1cm4gQnVmZmVyIEAgQXJyYXkuZnJvbSBAIHNlY3JldF9vY3RlY3RzXG5cbiAgICBfcmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlc1xuXG4gICAgX3BhY2tTaGFyZSh0aHJlc2hvbGQsIHgsIHlfdmVjKSA6OlxuICAgICAgcmV0dXJuIEJ1ZmZlciBAIFt0aHJlc2hvbGQsIHhdLmNvbmNhdCh5X3ZlYylcblxuICAgIF91bnBhY2tTaGFyZShidWYpIDo6XG4gICAgICBpZiAnc3RyaW5nJyA9PT0gdHlwZW9mIGJ1ZiA6OlxuICAgICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYsICdiYXNlNjQnKVxuICAgICAgZWxzZSBpZiAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgOjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcmUgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZ1wiKVxuXG4gICAgICByZXR1cm4gQHt9IHRocmVzaG9sZDogYnVmWzBdLCB4OiBidWZbMV0sIHlfdmVjOiBidWYuc2xpY2UoMilcblxuICAgIHN0YXRpYyBnZW5lcmF0ZVNoYXJlcyhzZWNyZXQsIHRocmVzaG9sZFNoYXJlcywgdG90YWxTaGFyZXMpIDo6XG4gICAgICByZXR1cm4gbmV3IFNoYW1pclRocmVzaG9sZFNlY3JldFNoYXJlX0dGMjU2KClcbiAgICAgICAgLmdlbmVyYXRlKHNlY3JldCwgdGhyZXNob2xkU2hhcmVzLCB0b3RhbFNoYXJlcylcblxuICAgIHN0YXRpYyB1bmxvY2tTaGFyZXMoc2hhcmVzX29mX3NlY3JldCwgdmFsdWVJZlVuZGVyVGhyZXNob2xkKSA6OlxuICAgICAgcmV0dXJuIG5ldyBTaGFtaXJUaHJlc2hvbGRTZWNyZXRTaGFyZV9HRjI1NigpXG4gICAgICAgIC51bmxvY2soc2hhcmVzX29mX3NlY3JldCwgdmFsdWVJZlVuZGVyVGhyZXNob2xkKVxuXG5cbiAgcmV0dXJuIFNoYW1pclRocmVzaG9sZFNlY3JldFNoYXJlX0dGMjU2XG4iXX0=