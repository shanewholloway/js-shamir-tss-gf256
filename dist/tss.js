"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (Buffer, randomBytes) {

  class ShamirThresholdSecretShare_GF256 {
    constructor() {
      this._randomBytes = randomBytes;
    }

    generate(secret, thresholdShares, totalShares) {
      if (!Buffer.isBuffer(secret)) {
        throw new Error("Expected secret to be a buffer");
      }

      if (thresholdShares <= 0) {
        throw new Error("Expected a positive threshold count");
      }

      if (null == totalShares) {
        totalShares = thresholdShares;
      } else if (totalShares < thresholdShares) {
        throw new Error("Expected the total count to be greater than the threshold count");
      }

      // initialize random Galois Field polynomials using provided
      // octects of secret for a0 coefficients
      const gf_polys = Array.from(secret, a0_secret => {
        let poly = this._randomBytes(thresholdShares);
        poly[0] = a0_secret; // use specified a0 as secret
        return poly;
      });

      // compute the shares given the Galois Field polynomials
      return new Array(totalShares).fill(null).map((_, i) => {
        const x = 1 + i,
              y_vec = gf_polys.map(poly => compute_poly(x, poly));
        return this._packShare(thresholdShares, x, y_vec);
      });
    }

    unlock(shares, valueIfUnderThreshold) {
      shares = Array.from(shares, this._unpackShare);
      const threshold = shares[0].threshold;
      if (shares.length < threshold) {
        if (undefined !== valueIfUnderThreshold) {
          return valueIfUnderThreshold;
        }
        throw new Error('Number of shares did not meet threshold to unlock shared secret');
      }

      const u = shares.slice(0, threshold).map(s => s.x);

      // v_vec = zip @ shares.map(s => s.y_vec)
      const v_vec = Array.from(shares[0].y_vec, (_, i) => shares.map(s => s.y_vec[i]));

      // Lagrange interpolation integrates the split share into the original secret
      const secret_octects = lagrange_interpolate(u, v_vec);
      return Buffer(Array.from(secret_octects));
    }

    _packShare(threshold, x, y_vec) {
      return Buffer([threshold, x].concat(y_vec));
    }

    _unpackShare(buf) {
      if ('string' === typeof buf) {
        buf = Buffer.from(buf, 'base64');
      } else if (!Buffer.isBuffer(buf)) {
        throw new Error("Share must be a buffer or a string");
      }

      return { threshold: buf[0], x: buf[1], y_vec: buf.slice(2) };
    }

    static generateShares(secret, thresholdShares, totalShares) {
      return new ShamirThresholdSecretShare_GF256().generate(secret, thresholdShares, totalShares);
    }

    static unlockShares(shares_of_secret, valueIfUnderThreshold) {
      return new ShamirThresholdSecretShare_GF256().unlock(shares_of_secret, valueIfUnderThreshold);
    }
  }

  return ShamirThresholdSecretShare_GF256;
};

// vim: ts=2 sw=2 expandtab filetype=javascript
const { compute_poly, lagrange_interpolate } = require('./gf256_math');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvdHNzLmpzeSJdLCJuYW1lcyI6WyJCdWZmZXIiLCJyYW5kb21CeXRlcyIsIlNoYW1pclRocmVzaG9sZFNlY3JldFNoYXJlX0dGMjU2IiwiX3JhbmRvbUJ5dGVzIiwiZ2VuZXJhdGUiLCJzZWNyZXQiLCJ0aHJlc2hvbGRTaGFyZXMiLCJ0b3RhbFNoYXJlcyIsImlzQnVmZmVyIiwiRXJyb3IiLCJnZl9wb2x5cyIsIkFycmF5IiwiZnJvbSIsImEwX3NlY3JldCIsInBvbHkiLCJmaWxsIiwibWFwIiwiXyIsImkiLCJ4IiwieV92ZWMiLCJjb21wdXRlX3BvbHkiLCJfcGFja1NoYXJlIiwidW5sb2NrIiwic2hhcmVzIiwidmFsdWVJZlVuZGVyVGhyZXNob2xkIiwiX3VucGFja1NoYXJlIiwidGhyZXNob2xkIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwidSIsInNsaWNlIiwicyIsInZfdmVjIiwic2VjcmV0X29jdGVjdHMiLCJsYWdyYW5nZV9pbnRlcnBvbGF0ZSIsImNvbmNhdCIsImJ1ZiIsImdlbmVyYXRlU2hhcmVzIiwidW5sb2NrU2hhcmVzIiwic2hhcmVzX29mX3NlY3JldCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztrQkFHZSxVQUFTQSxNQUFULEVBQWlCQyxXQUFqQixFQUE4Qjs7QUFFM0MsUUFBTUMsZ0NBQU4sQ0FBdUM7QUFBQTtBQUFBLFdBNENyQ0MsWUE1Q3FDLEdBNEN0QkYsV0E1Q3NCO0FBQUE7O0FBQ3JDRyxhQUFTQyxNQUFULEVBQWlCQyxlQUFqQixFQUFrQ0MsV0FBbEMsRUFBK0M7QUFDN0MsVUFBRyxDQUFDUCxPQUFPUSxRQUFQLENBQWdCSCxNQUFoQixDQUFKLEVBQThCO0FBQzVCLGNBQU0sSUFBSUksS0FBSixDQUFZLGdDQUFaLENBQU47QUFBa0Q7O0FBRXBELFVBQUdILG1CQUFtQixDQUF0QixFQUEwQjtBQUN4QixjQUFNLElBQUlHLEtBQUosQ0FBWSxxQ0FBWixDQUFOO0FBQXVEOztBQUV6RCxVQUFHLFFBQVFGLFdB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QU8sSUFBSUwsZ0NBQUosR0FDSkUsUUFESSxDQUNLQyxNQURMLEVBQ2FDLGVBRGIsRUFDOEJDLFdBRDlCLENBQVA7QUFDaUQ7O0FBRW5ELFdBQU9nQyxZQUFQLENBQW9CQyxnQkFBcEIsRUFBc0NmLHFCQUF0QyxFQUE2RDtBQUMzRCxhQUFPLElBQUl2QixnQ0FBSixHQUNKcUIsTUFESSxDQUNHaUIsZ0JBREgsRUFDcUJmLHFCQURyQixDQUFQO0FBQ2tEO0FBL0RmOztBQWtFdkMsU0FBT3ZCLGdDQUFQO0FBQXVDLEM7O0FBdkV6QztBQUNBLE1BQU0sRUFBQ21CLFlBQUQsRUFBZWMsb0JBQWYsS0FBdUNNLFFBQVEsY0FBUixDQUE3QyIsImZpbGUiOiJ0c3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aW06IHRzPTIgc3c9MiBleHBhbmR0YWIgZmlsZXR5cGU9amF2YXNjcmlwdFxuY29uc3Qge2NvbXB1dGVfcG9seSwgbGFncmFuZ2VfaW50ZXJwb2xhdGV9ID0gcmVxdWlyZSgnLi9nZjI1Nl9tYXRoJylcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oQnVmZmVyLCByYW5kb21CeXRlcykgOjpcblxuICBjbGFzcyBTaGFtaXJUaHJlc2hvbGRTZWNyZXRTaGFyZV9HRjI1NiA6OlxuICAgIGdlbmVyYXRlKHNlY3JldCwgdGhyZXNob2xkU2hhcmVzLCB0b3RhbFNoYXJlcykgOjpcbiAgICAgIGlmICFCdWZmZXIuaXNCdWZmZXIoc2VjcmV0KSA6OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IgQCBcIkV4cGVjdGVkIHNlY3JldCB0byBiZSBhIGJ1ZmZlclwiXG5cbiAgICAgIGlmIHRocmVzaG9sZFNoYXJlcyA8PSAwIDo6XG4gICAgICAgIHRocm93IG5ldyBFcnJvciBAIFwiRXhwZWN0ZWQgYSBwb3NpdGl2ZSB0aHJlc2hvbGQgY291bnRcIlxuXG4gICAgICBpZiBudWxsID09IHRvdGFsU2hhcmVzIDo6XG4gICAgICAgIHRvdGFsU2hhcmVzID0gdGhyZXNob2xkU2hhcmVzXG4gICAgICBlbHNlIGlmIHRvdGFsU2hhcmVzIDwgdGhyZXNob2xkU2hhcmVzIDo6XG4gICAgICAgIHRocm93IG5ldyBFcnJvciBAIFwiRXhwZWN0ZWQgdGhlIHRvdGFsIGNvdW50IHRvIGJlIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkIGNvdW50XCJcblxuICAgICAgLy8gaW5pdGlhbGl6ZSByYW5kb20gR2Fsb2lzIEZpZWxkIHBvbHlub21pYWxzIHVzaW5nIHByb3ZpZGVkXG4gICAgICAvLyBvY3RlY3RzIG9mIHNlY3JldCBmb3IgYTAgY29lZmZpY2llbnRzXG4gICAgICBjb25zdCBnZl9wb2x5cyA9IEFycmF5LmZyb20gQCBzZWNyZXQsIGEwX3NlY3JldCA9PiA6OlxuICAgICAgICBsZXQgcG9seSA9IHRoaXMuX3JhbmRvbUJ5dGVzKHRocmVzaG9sZFNoYXJlcylcbiAgICAgICAgcG9seVswXSA9IGEwX3NlY3JldCAvLyB1c2Ugc3BlY2lmaWVkIGEwIGFzIHNlY3JldFxuICAgICAgICByZXR1cm4gcG9seVxuXG4gICAgICAvLyBjb21wdXRlIHRoZSBzaGFyZXMgZ2l2ZW4gdGhlIEdhbG9pcyBGaWVsZCBwb2x5bm9taWFsc1xuICAgICAgcmV0dXJuIG5ldyBBcnJheSh0b3RhbFNoYXJlcykuZmlsbChudWxsKS5tYXAgQCAoXywgaSkgPT4gOjpcbiAgICAgICAgY29uc3QgeD0xK2ksIHlfdmVjPWdmX3BvbHlzLm1hcCBAIHBvbHkgPT4gY29tcHV0ZV9wb2x5KHgsIHBvbHkpXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWNrU2hhcmUodGhyZXNob2xkU2hhcmVzLCB4LCB5X3ZlYylcblxuXG4gICAgdW5sb2NrKHNoYXJlcywgdmFsdWVJZlVuZGVyVGhyZXNob2xkKSA6OlxuICAgICAgc2hhcmVzID0gQXJyYXkuZnJvbSBAIHNoYXJlcywgdGhpcy5fdW5wYWNrU2hhcmVcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHNoYXJlc1swXS50aHJlc2hvbGRcbiAgICAgIGlmIHNoYXJlcy5sZW5ndGggPCB0aHJlc2hvbGQgOjpcbiAgICAgICAgaWYgdW5kZWZpbmVkICE9PSB2YWx1ZUlmVW5kZXJUaHJlc2hvbGQgOjpcbiAgICAgICAgICByZXR1cm4gdmFsdWVJZlVuZGVyVGhyZXNob2xkXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIHNoYXJlcyBkaWQgbm90IG1lZXQgdGhyZXNob2xkIHRvIHVubG9jayBzaGFyZWQgc2VjcmV0JylcblxuICAgICAgY29uc3QgdSA9IHNoYXJlcy5zbGljZSgwLCB0aHJlc2hvbGQpLm1hcCBAIHMgPT4gcy54XG5cbiAgICAgIC8vIHZfdmVjID0gemlwIEAgc2hhcmVzLm1hcChzID0+IHMueV92ZWMpXG4gICAgICBjb25zdCB2X3ZlYyA9IEFycmF5LmZyb20gQCBzaGFyZXNbMF0ueV92ZWMsIChfLCBpKSA9PlxuICAgICAgICBzaGFyZXMubWFwIEAgcyA9PiBzLnlfdmVjW2ldXG5cbiAgICAgIC8vIExhZ3JhbmdlIGludGVycG9sYXRpb24gaW50ZWdyYXRlcyB0aGUgc3BsaXQgc2hhcmUgaW50byB0aGUgb3JpZ2luYWwgc2VjcmV0XG4gICAgICBjb25zdCBzZWNyZXRfb2N0ZWN0cyA9IGxhZ3JhbmdlX2ludGVycG9sYXRlKHUsIHZfdmVjKVxuICAgICAgcmV0dXJuIEJ1ZmZlciBAIEFycmF5LmZyb20gQCBzZWNyZXRfb2N0ZWN0c1xuXG4gICAgX3JhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXNcblxuICAgIF9wYWNrU2hhcmUodGhyZXNob2xkLCB4LCB5X3ZlYykgOjpcbiAgICAgIHJldHVybiBCdWZmZXIgQCBbdGhyZXNob2xkLCB4XS5jb25jYXQoeV92ZWMpXG5cbiAgICBfdW5wYWNrU2hhcmUoYnVmKSA6OlxuICAgICAgaWYgJ3N0cmluZycgPT09IHR5cGVvZiBidWYgOjpcbiAgICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmLCAnYmFzZTY0JylcbiAgICAgIGVsc2UgaWYgIUJ1ZmZlci5pc0J1ZmZlcihidWYpIDo6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNoYXJlIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmdcIilcblxuICAgICAgcmV0dXJuIEB7fSB0aHJlc2hvbGQ6IGJ1ZlswXSwgeDogYnVmWzFdLCB5X3ZlYzogYnVmLnNsaWNlKDIpXG5cbiAgICBzdGF0aWMgZ2VuZXJhdGVTaGFyZXMoc2VjcmV0LCB0aHJlc2hvbGRTaGFyZXMsIHRvdGFsU2hhcmVzKSA6OlxuICAgICAgcmV0dXJuIG5ldyBTaGFtaXJUaHJlc2hvbGRTZWNyZXRTaGFyZV9HRjI1NigpXG4gICAgICAgIC5nZW5lcmF0ZShzZWNyZXQsIHRocmVzaG9sZFNoYXJlcywgdG90YWxTaGFyZXMpXG5cbiAgICBzdGF0aWMgdW5sb2NrU2hhcmVzKHNoYXJlc19vZl9zZWNyZXQsIHZhbHVlSWZVbmRlclRocmVzaG9sZCkgOjpcbiAgICAgIHJldHVybiBuZXcgU2hhbWlyVGhyZXNob2xkU2VjcmV0U2hhcmVfR0YyNTYoKVxuICAgICAgICAudW5sb2NrKHNoYXJlc19vZl9zZWNyZXQsIHZhbHVlSWZVbmRlclRocmVzaG9sZClcblxuXG4gIHJldHVybiBTaGFtaXJUaHJlc2hvbGRTZWNyZXRTaGFyZV9HRjI1NlxuIl19